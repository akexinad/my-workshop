

CURSOR BASED PAGINATION
=======================

In cursor-based pagination, a "cursor" is used to keep track of where in the data set the next items should
be fetched from. Sometimes the cursor can be quite simple and just refer to the ID of the last object
fetched, but in some cases - ex lists sorted according to some criteria = the cursor needs to 
encode the sorting criteria in addition to the ID of the last object fetched.

Implementing cursor-based pagination on the client isn't all that different from offset-based pagination,
but instead of using an absolute offset, we keep a reference to the last object fetched and information 
about the sort order used.




APOLLO GRAPH MANAGER
====================

- Pushing your schema to Apollo Graph Manager
$ npx apollo service:push --endpoint=http://localhost:4000


- And if you make changes to your schema, you can always check for breaking changes with: 
$ npx apollo service:check --endpoint=http://localhost:4000

Apollo Graph manager is great because it has features such as:
- Schema Explorer
- Schema History
- Performance Analytics
- Client Awareness

See https://www.apollographql.com/docs/tutorial/production/#what-are-the-benefits-of-graph-manager




UPDATING LOCAL DATA
===================

There are two ways to update local data:

1. DIRECT CACHE WRITES
    - These are convenient when you want to write a simple field, like a boolean or string.
    - Just invoke client.writeData() and pass in an object.
    - Or we can use the update method inside the useMutation hook to update the cache.


2. CLIENT RESOLVERS
    - local/client have the same functionality as the remote resolvers.
    - The only difference is that the Apollo cache is already added to the context for you.
    - Inside the resolver, you'll use the cache to read and write data. 